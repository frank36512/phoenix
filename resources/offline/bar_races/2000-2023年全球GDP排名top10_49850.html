<!DOCTYPE html>
<html style="height: 100%">
<head>
    <meta charset="utf-8">
    <title>2000-2023年全球GDP排名top10 - 动态排序图</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <style>
        body { margin: 0; background-color: #f0f2f5; font-family: 'Microsoft YaHei', sans-serif; }
        #bg-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
        }
        #container { height: 100vh; width: 100vw; position: relative; z-index: 1; }
    </style>
</head>
<body style="height: 100%; margin: 0">
    <div id="bg-layer"></div>
    <div id="container"></div>

    <script type="text/javascript">
        var dom = document.getElementById('container');
        var myChart = echarts.init(dom);
        var rawData = {"title": "2000-2023年全球主要经济体GDP排名演变", "subtitle": "单位：亿美元", "categories": ["美国", "中国", "日本", "德国", "印度", "英国", "法国", "巴西", "意大利", "加拿大"], "timeline": ["2000", "2001", "2002", "2003", "2004", "2005", "2006", "2007", "2008", "2009", "2010", "2011", "2012", "2013", "2014", "2015", "2016", "2017", "2018", "2019", "2020", "2021", "2022", "2023"], "data": [[102523, 12113, 49683, 19488, 4683, 16652, 13662, 6554, 11471, 7446], [105818, 13393, 43747, 19458, 4939, 16439, 13776, 5591, 11707, 7389], [109364, 14705, 41828, 20770, 5239, 17869, 14984, 5101, 12763, 7579], [114582, 16602, 45195, 25016, 6183, 20567, 18453, 5582, 15771, 8955], [122137, 19553, 48931, 28144, 7215, 24230, 21211, 6692, 18032, 10264], [130366, 22873, 48314, 28484, 8342, 25448, 21980, 8916, 18578, 11693], [138146, 27548, 46016, 29947, 9484, 27099, 23206, 11076, 19479, 13192], [144518, 35556, 45767, 34259, 12387, 30955, 26606, 13970, 22131, 14649], [147128, 45943, 51066, 37448, 12240, 29316, 29303, 16958, 24086, 15528], [144489, 51061, 52894, 34112, 13653, 24258, 27007, 16669, 21999, 13765], [150489, 60871, 57590, 34024, 16756, 24913, 26475, 22088, 21361, 16173], [155997, 75515, 62331, 37493, 18230, 26748, 28653, 26161, 22949, 17933], [162539, 85322, 62723, 35332, 18276, 27191, 26836, 24652, 20869, 18283], [168431, 95704, 52095, 37464, 18567, 28032, 28118, 24728, 21419, 18465], [175506, 104756, 48969, 38890, 20391, 30655, 28561, 24560, 21620, 18057], [182060, 110615, 44449, 33575, 21035, 29348, 24394, 18022, 18366, 15565], [186951, 112332, 50036, 34698, 22947, 26996, 24722, 17956, 18774, 15279], [194773, 123104, 49308, 36908, 26514, 26624, 25951, 20635, 19611, 16492], [205330, 138948, 50378, 39772, 27029, 28605, 27909, 19169, 20919, 17253], [213809, 142799, 51233, 38883, 28315, 28570, 27288, 18732, 20113, 17415], [210604, 146877, 50401, 38896, 26676, 26978, 26390, 14487, 18972, 16454], [233150, 177340, 50346, 42599, 31503, 31415, 29578, 16089, 21143, 20014], [254627, 179631, 42311, 40721, 33850, 30706, 27829, 19200, 20104, 21398], [273600, 177900, 42100, 44500, 37300, 33400, 30300, 21300, 22500, 21400]]};
        
        // Configuration Object
        var config = {
            colors: ['#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de', '#3ba272', '#fc8452', '#9a60b4', '#ea7ccc'],
            fontFamily: 'Microsoft YaHei',
            fontSize: 24,
            fontColor: '#333',
            backgroundColor: '#f0f2f5', // Deprecated in favor of backgroundStyle for complex backgrounds
            backgroundStyle: '#f0f2f5', // Can be color or CSS gradient
            backgroundImage: "",
            bgOpacity: 1.0,
            showLabel: true,
            labelFont: 'monospace',
            updateFrequency: 2000,
            dataSource: "",
            // New Bar Styles
            barColorMode: 'category', // 'category', 'single', 'gradient'
            barSingleColor: '#5470c6',
            barGradient: null, // ECharts gradient object
            barBorderRadius: 5,
            barOpacity: 1.0
        };

        // Apply global styles
        function applyGlobalStyles() {
            // Prefer backgroundStyle, fallback to backgroundColor
            var bgStyle = config.backgroundStyle || config.backgroundColor;
            
            // Predefined Gradients and Colors
            var gradients = {
                'rainbow': 'linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3)',
                'cool': 'linear-gradient(120deg, #84fab0 0%, #8fd3f4 100%)',
                'warm': 'linear-gradient(120deg, #f6d365 0%, #fda085 100%)',
                'neon': 'linear-gradient(to right, #00f260, #0575e6)',
                'sunset': 'linear-gradient(to right, #ff7e5f, #feb47b)',
                'ocean': 'linear-gradient(to right, #2E3192, #1BFFFF)',
                'dark': '#1a1a1a',
                'light': '#f0f2f5'
            };

            if (gradients[bgStyle]) {
                bgStyle = gradients[bgStyle];
            }
            
            // Check if it's a gradient (contains "gradient") or simple color
            if (bgStyle && bgStyle.indexOf('gradient') !== -1) {
                 document.body.style.background = bgStyle;
            } else {
                 document.body.style.background = "";
                 document.body.style.backgroundColor = bgStyle;
            }

            var bgLayer = document.getElementById('bg-layer');
            if (config.backgroundImage) {
                bgLayer.style.backgroundImage = config.backgroundImage;
                bgLayer.style.opacity = config.bgOpacity;
            } else {
                bgLayer.style.backgroundImage = "none";
            }
            document.body.style.fontFamily = config.fontFamily;
        }
        applyGlobalStyles();
        
        var currentYearIndex = 0;
        var timer = null;

        // 1. Static/Structural Option (Grids, Axes)
        function getAxisOption() {
            var itemCount = rawData.categories.length;
            return {
                grid: {
                    left: 150, // Increase left margin to accommodate rank numbers
                    right: 80,
                    top: 80,
                    bottom: 30,
                    containLabel: false
                },
                xAxis: {
                    type: 'value',
                    max: 'dataMax',
                    axisLabel: {
                        formatter: function (n) {
                            return Math.round(n);
                        },
                        fontFamily: config.fontFamily
                    }
                },
                yAxis: {
                    type: 'category',
                    inverse: true,
                    max: itemCount - 1,
                    axisLabel: {
                        show: false // Hide default labels
                    },
                    axisLine: { show: false },
                    axisTick: { show: false },
                    animationDuration: 300,
                    animationDurationUpdate: 300
                }
            };
        }

        // Calculate and return graphic elements for rank numbers
        function getRankGraphic() {
            var itemCount = rawData.categories.length;
            var elements = [];
            
            // Try to use convertToPixel for perfect alignment
            var useExact = false;
            try {
                // Check if coordinate system is ready by testing index 0
                // We use {gridIndex: 0} or {yAxisIndex: 0}
                var testPos = myChart.convertToPixel({yAxisIndex: 0}, 0);
                if (testPos) {
                    useExact = true;
                }
            } catch (e) {
                // Ignore
            }

            if (useExact) {
                for (var i = 0; i < itemCount; i++) {
                    var position = myChart.convertToPixel({yAxisIndex: 0}, i);
                    elements.push({
                        type: 'text',
                        left: 100, // Fixed horizontal position
                        top: position[1], // Exact Y coordinate from axis
                        style: {
                            text: (i + 1).toString(),
                            textAlign: 'center',
                            textVerticalAlign: 'middle',
                            fontSize: 16,
                            fontWeight: 'bold',
                            fontFamily: config.fontFamily,
                            fill: config.fontColor
                        },
                        z: 100,
                        silent: true
                    });
                }
            } else {
                // Fallback to manual calculation (approximate)
                var top = 80;
                var bottom = 30;
                var height = myChart.getHeight() - top - bottom;
                var step = height / itemCount;
                
                for (var i = 0; i < itemCount; i++) {
                    elements.push({
                        type: 'text',
                        left: 100,
                        top: top + i * step + step / 2,
                        style: {
                            text: (i + 1).toString(),
                            textAlign: 'center',
                            textVerticalAlign: 'middle',
                            fontSize: 16,
                            fontWeight: 'bold',
                            fontFamily: config.fontFamily,
                            fill: config.fontColor
                        },
                        z: 100,
                        silent: true
                    });
                }
            }
            return elements;
        }

        // 2. Dynamic Option (Series, Title, Graphic)
        function getSeriesOption(index) {
            var year = rawData.timeline[index];
            var dataValues = rawData.data[index];
            var itemCount = rawData.categories.length;
            
            var seriesData = [];
            for (var i = 0; i < itemCount; i++) {
                var itemColor;
                if (config.barColorMode === 'single') {
                    itemColor = config.barSingleColor;
                } else if (config.barColorMode === 'gradient' && config.barGradient) {
                    itemColor = config.barGradient;
                } else {
                    // Category/Default
                    itemColor = config.colors[i % config.colors.length];
                }

                seriesData.push({
                    value: dataValues[i],
                    name: rawData.categories[i],
                    itemStyle: {
                        color: itemColor
                    }
                });
            }

            return {
                title: {
                    text: rawData.title,
                    subtext: rawData.subtitle + ' (' + year + ')',
                    left: 'center',
                    top: 20,
                    textStyle: { 
                        fontSize: config.fontSize, 
                        fontWeight: 'bold',
                        fontFamily: config.fontFamily
                    }
                },
                series: [{
                    // Dynamic Race Series
                    realtimeSort: true,
                    name: 'Value',
                    type: 'bar',
                    data: seriesData,
                    encode: {
                        x: 'value',
                        y: 'name'
                    },
                    label: {
                        show: config.showLabel,
                        position: 'right',
                        valueAnimation: true,
                        fontFamily: config.labelFont,
                        color: config.fontColor,
                        formatter: function(params) {
                             return params.name + '  ' + Math.round(params.value);
                        }
                    },
                    itemStyle: {
                        borderRadius: [0, config.barBorderRadius, config.barBorderRadius, 0],
                        opacity: config.barOpacity
                    }
                }],
                animationDuration: 0,
                animationDurationUpdate: config.updateFrequency,
                animationEasing: 'linear',
                animationEasingUpdate: 'linear',
                graphic: {
                    elements: [{
                        type: 'text',
                        right: 60,
                        bottom: 60,
                        style: {
                            text: year,
                            font: 'bold 80px ' + config.labelFont,
                            fill: 'rgba(100, 100, 100, 0.25)'
                        },
                        z: 100
                    }].concat(config.dataSource ? [{
                        type: 'text',
                        right: 10,
                        bottom: 10,
                        style: {
                            text: '数据来源: ' + config.dataSource,
                            font: '14px ' + config.fontFamily,
                            fill: config.fontColor
                        },
                        z: 100
                    }] : []).concat(getRankGraphic()) // Add rank numbers
                }
            };
        }

        // Function to update config from outside
        function updateConfig(newConfig) {
            Object.assign(config, newConfig);
            
            // Calculate updateFrequency if duration is provided
            if (newConfig.duration && rawData.timeline && rawData.timeline.length > 1) {
                config.updateFrequency = newConfig.duration / (rawData.timeline.length - 1);
                
                // Restart animation to apply new speed
                if (timer) clearInterval(timer);
                runAnimation();
            }
            
            applyGlobalStyles();
            
            // Update structural config (Fonts, Colors)
            myChart.setOption(getAxisOption());
            
            // Update data/series config
            myChart.setOption(getSeriesOption(currentYearIndex));
        }

        // Initial render
        myChart.setOption(getAxisOption());
        myChart.setOption(getSeriesOption(0));

        function runAnimation() {
            if (timer) clearInterval(timer);
            currentYearIndex = 0;
            myChart.setOption(getSeriesOption(0));
            
            timer = setInterval(function () {
                currentYearIndex++;
                if (currentYearIndex >= rawData.timeline.length) {
                    clearInterval(timer);
                    return;
                }
                myChart.setOption(getSeriesOption(currentYearIndex));
            }, config.updateFrequency);
        }

        setTimeout(runAnimation, 1000);

        window.addEventListener('resize', function() {
            myChart.resize();
            // Force update of graphic elements to realign with new coordinates
            myChart.setOption(getSeriesOption(currentYearIndex));
        });

        // Video Export Support: Deterministic Rendering
        window.prepareTimeline = function() {
            if (timer) clearInterval(timer);
            currentYearIndex = 0;
            // Reset to start
            myChart.setOption(getSeriesOption(0));
            
            // Calculate total duration
            // We have N points. There are N-1 intervals of duration config.updateFrequency.
            var totalDuration = (rawData.timeline.length - 1) * config.updateFrequency;
            // Add 2 seconds buffer at the end
            totalDuration += 2000; 
            
            return Promise.resolve({
                totalDuration: totalDuration
            });
        };

        window.startSlowMotionAnimation = function(speedRatio) {
            if (timer) clearInterval(timer);
            
            // Slow down
            var originalFreq = config.updateFrequency;
            var newFreq = originalFreq / speedRatio;
            
            // Update config locally
            config.updateFrequency = newFreq;
            
            // Important: Update ECharts animation duration to match new frequency
            // We need to override the default options
            myChart.setOption({
                animationDuration: 0, 
                animationDurationUpdate: newFreq,
                animationEasing: 'cubicInOut', // Smoother easing
                animationEasingUpdate: 'cubicInOut' // Smoother easing
            });
            
            currentYearIndex = 0;
            myChart.setOption(getSeriesOption(0));
            
            window.animationFinished = false;
            
            // Start loop
            timer = setInterval(function () {
                currentYearIndex++;
                if (currentYearIndex >= rawData.timeline.length) {
                    clearInterval(timer);
                    window.animationFinished = true;
                    return;
                }
                myChart.setOption(getSeriesOption(currentYearIndex));
            }, newFreq);
            
            return {
                totalDuration: (rawData.timeline.length - 1) * newFreq + 2000 / speedRatio
            };
        };

        window.seekTo = function(time_ms) {
             var freq = config.updateFrequency;
             var totalPoints = rawData.timeline.length;
             
             // Calculate index and ratio
             var index = Math.floor(time_ms / freq);
             var ratio = (time_ms % freq) / freq;
             
             if (index >= totalPoints - 1) {
                 index = totalPoints - 1;
                 ratio = 0; // Finished
             }
             
             // Interpolate Data
             var currentValues = rawData.data[index];
             var nextValues = rawData.data[Math.min(index + 1, totalPoints - 1)];
             
             var interpolatedSeriesData = [];
             for (var i = 0; i < rawData.categories.length; i++) {
                 var startVal = currentValues[i];
                 var endVal = nextValues[i];
                 var val = startVal + (endVal - startVal) * ratio;
                 
                 // Color logic (same as getSeriesOption)
                 var itemColor;
                 if (config.barColorMode === 'single') {
                    itemColor = config.barSingleColor;
                 } else if (config.barColorMode === 'gradient' && config.barGradient) {
                    itemColor = config.barGradient;
                 } else {
                    itemColor = config.colors[i % config.colors.length];
                 }

                 interpolatedSeriesData.push({
                     value: val,
                     name: rawData.categories[i],
                     itemStyle: { color: itemColor }
                 });
             }
             
             var year = rawData.timeline[index]; 
             
             var option = {
                 series: [{
                     data: interpolatedSeriesData,
                     animation: false, // CRITICAL: No internal animation
                     realtimeSort: true,
                     label: {
                        show: config.showLabel,
                        position: 'right',
                        valueAnimation: false,
                        formatter: function(params) {
                             return params.name + '  ' + Math.round(params.value);
                        },
                        fontFamily: config.labelFont,
                        color: config.fontColor
                    },
                    itemStyle: {
                        borderRadius: [0, config.barBorderRadius, config.barBorderRadius, 0],
                        opacity: config.barOpacity
                    }
                 }],
                 animation: false,
                 graphic: {
                     elements: [{
                        type: 'text',
                        right: 60,
                        bottom: 60,
                        style: {
                            text: year,
                            font: 'bold 80px ' + config.labelFont,
                            fill: 'rgba(100, 100, 100, 0.25)'
                        }
                     }].concat(config.dataSource ? [{
                        type: 'text',
                        right: 10,
                        bottom: 10,
                        style: {
                            text: '数据来源: ' + config.dataSource,
                            font: '14px ' + config.fontFamily,
                            fill: config.fontColor
                        }
                     }] : []).concat(getRankGraphic()) 
                 }
             };
             
             myChart.setOption(option);
        };

    </script>
</body>
</html>